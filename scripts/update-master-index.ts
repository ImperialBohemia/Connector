
import fs from 'fs';
import path from 'path';

const ROOT_DIR = process.cwd();
const OUTPUT_FILE = path.join(ROOT_DIR, 'MASTER_INDEX.md');

function getProjectIdentity() {
  try {
    const configPath = path.join(ROOT_DIR, 'lib', 'config.ts');
    if (!fs.existsSync(configPath)) return { name: 'Unknown', description: 'No config found' };

    const content = fs.readFileSync(configPath, 'utf-8');

    // Simple regex extraction to avoid compiling TS
    const nameMatch = content.match(/name:\s*"([^"]+)"/);
    const descMatch = content.match(/description:\s*"([^"]+)"/);
    const urlMatch = content.match(/url:\s*process\.env\.NEXT_PUBLIC_SITE_URL\s*\|\|\s*"([^"]+)"/);

    return {
      name: nameMatch ? nameMatch[1] : 'Unknown',
      description: descMatch ? descMatch[1] : 'Unknown',
      url: urlMatch ? urlMatch[1] : 'Unknown'
    };
  } catch (error) {
    return { name: 'Error', description: 'Could not read config' };
  }
}

function getRoutes(dir: string, baseRoute = ''): string[] {
  let routes: string[] = [];
  const entries = fs.readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);

    if (entry.isDirectory()) {
      // Next.js App Router logic
      const routeName = entry.name;
      const newRoute = baseRoute === '' ? `/${routeName}` : `${baseRoute}/${routeName}`;

      // Recurse
      routes = [...routes, ...getRoutes(fullPath, newRoute)];
    } else {
      if (entry.name === 'page.tsx') {
        routes.push(baseRoute || '/');
      } else if (entry.name === 'route.ts') {
        routes.push(`${baseRoute} (API)`);
      }
    }
  }
  return routes;
}

function getPackageJson() {
  try {
    const pkgPath = path.join(ROOT_DIR, 'package.json');
    return JSON.parse(fs.readFileSync(pkgPath, 'utf-8'));
  } catch (e) {
    return {};
  }
}

function getScripts() {
  const pkg = getPackageJson();
  return pkg.scripts || {};
}

function getDependencies() {
  const pkg = getPackageJson();
  return {
    ...pkg.dependencies,
    ...pkg.devDependencies
  };
}

function getFileTree(dir: string, depth = 0): string {
  if (depth > 3) return ''; // Limit depth
  const indent = '  '.repeat(depth);
  let output = '';

  try {
    const entries = fs.readdirSync(dir, { withFileTypes: true });

    // Sort directories first
    entries.sort((a, b) => {
      if (a.isDirectory() && !b.isDirectory()) return -1;
      if (!a.isDirectory() && b.isDirectory()) return 1;
      return a.name.localeCompare(b.name);
    });

    for (const entry of entries) {
      if (entry.name.startsWith('.') || entry.name === 'node_modules' || entry.name === 'dist') continue;

      output += `${indent}- ${entry.name}${entry.isDirectory() ? '/' : ''}\n`;

      if (entry.isDirectory()) {
        output += getFileTree(path.join(dir, entry.name), depth + 1);
      }
    }
  } catch (e) {
    return `${indent}- (Error reading directory)\n`;
  }
  return output;
}

function generateIndex() {
  console.log('ðŸ§  Scanning Neural Network (Project Structure)...');

  const identity = getProjectIdentity();
  const scripts = getScripts();
  const dependencies = getDependencies();

  // Routes
  const appDir = path.join(ROOT_DIR, 'app');
  const routes = fs.existsSync(appDir) ? getRoutes(appDir) : [];
  const uniqueRoutes = Array.from(new Set(routes)).sort();

  // Trees
  const libTree = fs.existsSync(path.join(ROOT_DIR, 'lib')) ? getFileTree(path.join(ROOT_DIR, 'lib')) : '';
  const scriptsTree = fs.existsSync(path.join(ROOT_DIR, 'scripts')) ? getFileTree(path.join(ROOT_DIR, 'scripts')) : '';

  const content = `# ðŸ§  Master Index (Brain)
> **Auto-Generated by Connector** | Last Updated: ${new Date().toISOString()}
> This file serves as the cognitive map for AI Agents (Jules/Connector) to understand the system instantly.

## 1. Project Identity
- **Name:** ${identity.name}
- **Description:** ${identity.description}
- **Production URL:** ${identity.url}

## 2. Neural Pathways (Routes)
These are the accessible public endpoints and pages.

${uniqueRoutes.map(r => `- \`${r}\``).join('\n')}

## 3. Capabilities (Scripts)
Commands available in \`package.json\`:

| Command | Action |
| :--- | :--- |
${Object.entries(scripts).map(([key, val]) => `| \`npm run ${key}\` | \`${val}\` |`).join('\n')}

## 4. Connected Modules (API/Libs)
External brains and tools connected to the system:

| Module | Version | Type |
| :--- | :--- | :--- |
${Object.entries(dependencies).map(([key, val]) => `| \`${key}\` | \`${val}\` | \`${key.includes('types') || key.includes('eslint') || key.includes('prettier') ? 'DevTool' : 'Core'}\` |`).join('\n')}

## 5. System Structure (File Map)

### Logic Core (\`lib/\`)
${libTree}
### Automation (\`scripts/\`)
${scriptsTree}

## 6. Integration Points
- **Deployment:** Managed by \`scripts/deploy.ts\` (Calls this indexer).
- **Quality:** Managed by \`scripts/quality-audit.ts\`.
- **Bing Indexing:** Managed by \`scripts/submit-indexnow.ts\`.

---
*Note: Do not edit this file manually. It is overwritten on every deployment.*
`;

  fs.writeFileSync(OUTPUT_FILE, content);
  console.log(`âœ… Master Index updated at ${OUTPUT_FILE}`);
}

generateIndex();
